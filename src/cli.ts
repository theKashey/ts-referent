#!/usr/bin/env node

import { writeFileSync, mkdirSync } from 'fs';
import { dirname, join, relative } from 'path';

import { findRootSync } from '@manypkg/find-root';
import { getPackages, Package } from '@manypkg/get-packages';
import sade from 'sade';

import { readRulesFromFileSystem } from './configuration-discovery';
import { ConfigurationFile, Kind, KindCache, KindSet } from './types';

const getRoot = (): string => {
  try {
    return findRootSync(process.cwd());
  } catch (e) {
    throw new Error('no monorepo has been detected');
  }
};

const getWorkspace = async (root: string) => {
  try {
    return (await getPackages(root)).packages;
  } catch (e) {
    throw new Error('no monorepo has been detected');
  }
};

const getKinds = (kidsCache: KindCache, dir: string): Readonly<ConfigurationFile> => {
  const kinds: KindSet = {};
  const base: ConfigurationFile = {};

  kidsCache.forEach(([path, file]) => {
    if (dir.includes(path)) {
      Object.assign(kinds, file.kinds);
    }

    Object.assign(base, file);
  });

  return { kinds, ...base };
};

const writeJSON = (file: string, content: any) => {
  try {
    mkdirSync(dirname(file), { recursive: true });
  } catch (e) {
    // suppress
  }

  console.log('writing', file);

  writeFileSync(
    file,
    '/* this file was generated by ts-referent. Do not edit */\n\n' + JSON.stringify(content, null, 2)
  );
};

const stringOrFunction = <T extends unknown[]>(
  x: undefined | string | ((...arg: T) => string),
  ...arg: T
): string | undefined => {
  if (!x) {
    return undefined;
  }

  if (typeof x === 'string') {
    return x;
  }

  return x(...arg);
};

const defineReference = (root: string, kindName: string, kind: Kind, pkg: Package) => {
  const configLocation = join(root, '.referenced', pkg.packageJson.name.replace('/', '-'));
  const location = join(configLocation, 'config');
  const output = join(
    stringOrFunction(kind.outDirRoot, pkg.packageJson, pkg.dir) ?? configLocation,
    'output',
    kindName
  );

  const config = {
    extends: relative(location, kind.extends || join(pkg.dir, 'tsconfig.json')),
    include: [
      ...kind.include.map((i) => `${relative(location, pkg.dir)}/${i}`),
      ...(kind.imports?.map((i) => relative(location, i)) ?? []),
    ],
    exclude: [
      ...(kind.exclude?.map((i) => `${relative(location, pkg.dir)}/${i}`) ?? []),
      ...(kind.ignores?.map((i) => relative(location, i)) ?? []),
    ],
    compilerOptions: {
      composite: true,
      ...kind.compilerOptions,
      outDir: relative(location, output),
      rootDir: relative(location, pkg.dir),
      baseUrl: relative(location, pkg.dir),
      tsBuildInfoFile: join(configLocation, '.cache', kindName),
      types: kind.types,
    },
  };
  const configFile = join(location, `tsconfig.${kindName}.json`);
  writeJSON(configFile, config);

  return configFile;
};

const getKindsCache = (packages: Package[], root: string): KindCache => {
  return Array.from(
    readRulesFromFileSystem(
      root,
      packages.map((pkg) => pkg.dir)
    ).entries()
  ).sort((a, b) => a[0].length - b[0].length);
};

const program = sade('ts-referent', false).version(require('../../package.json').version);

program.command('build', 'creates references').action(async () => {
  const root = getRoot();
  const packages = await getWorkspace(root);
  const kindsCache = getKindsCache(packages, root);

  packages.forEach((pkg) => {
    const { kinds, ...conf } = getKinds(kindsCache, pkg.dir);

    if (!conf.extends) {
      throw new Error('base `extends` is not defined for ' + pkg.dir);
    }

    if (!kinds || Object.keys(kinds).length === 0) {
      throw new Error('kinds configuration is missing for ' + pkg.dir);
    }

    const configuration = {
      extends: relative(pkg.dir, conf.extends),
      include: [],
      exclude: [],
      references: Object.keys(kinds).map((kind) => ({
        path: relative(pkg.dir, defineReference(root, kind, kinds[kind], pkg)),
      })),
    };
    const pkgConfig = join(pkg.dir, 'tsconfig.json');
    writeJSON(pkgConfig, configuration);
  });
});

// program
//     .command('check', 'checks correctness')
//     .action(() => {
//
//     });

program
  .command('glossary <configFileName>', 'generates glossary for all packages in the monorepo')
  .action(async (fileName) => {
    const root = getRoot();
    const packages = await getWorkspace(root);

    writeJSON(fileName, {
      files: [],
      references: packages.map((pkg) => ({ path: pkg.dir })),
    });
  });

program.command('paths <configFileName>', 'generates glossary for paths used in monorepo').action(async (fileName) => {
  const root = getRoot();
  const packages = await getWorkspace(root);
  const kindsCache = getKindsCache(packages, root);

  writeJSON(fileName, {
    compilerOptions: {
      paths: packages.reduce<Record<string, string[]>>((acc, pkg) => {
        const { entrypointResolver } = getKinds(kindsCache, pkg.dir);

        [...(entrypointResolver?.(pkg.packageJson, pkg.dir) ?? []), ['', '']].forEach(([entry, point]) => {
          acc[`${pkg.packageJson.name}${entry}`] = [join(pkg.dir, point)];
        });

        return acc;
      }, {}),
    },
  });
});

program.parse(process.argv);
